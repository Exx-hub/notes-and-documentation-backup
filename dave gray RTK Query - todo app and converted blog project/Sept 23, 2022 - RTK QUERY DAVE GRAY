September 23, 2022


Dave Gray RTK series - Video#6 RTK QUERY


first take on RTK query.
compare with no rtk query after.
encountered this in the mern stack app but was too confusing that's why i need to study this first.






1. create apiSlice using createApi and fetchBaseQuery

export const apiSlice = createApi({
  reducerPath: "api",
  baseQuery: fetchBaseQuery({ baseUrl: "http://localhost:3500" }),
  endpoints: (builder) => ({
    getTodos: builder.query({ query: () => "/todos" }),
  }),
});


2. hooks are automatically generated. gets methods from endpoints

export const { useGetTodosQuery } = apiSlice;

get requests are builder.query and other requests are build.mutation


3. wrap your app with the ApiProvider and pass apiSlice as api prop


index.js

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <ApiProvider api={apiSlice}>
      <App />
    </ApiProvider>
  </React.StrictMode>
);


--now your app if wrapped with the ApiProvider. you can use autogenerated hooks anywhere in your app.



4. use hooks in the components you want to.

---these hooks return 2 items. [function, object]

function => Query function. addtodo get request for example
object => response object (isLoading,isError, isSuccess, etc.) 


****RTK QUERY => like axios. interacting with API. CRUD operations.

--if combined with entity adapter, which is like an entity state, an object holding your state with ids array.

---use rtk query to fetch then save to created entity adapter....


//createApi is like axios, but in a separate file (slice) and auto generate hooks to use in components.
// also like asyncThunk.

// api and date fethcing logic separated from components. turned into custom hooks.

// this example does not use global store but can be used with a global store



5. crud operations functional now. but when you update add or delete, the data does not get updated

-cached data is still shown

solution: 

- add tagTypes: ['Todos'] --- tags in general
- providesTags => add tag to the cached fetched data
- add invalidateTags: ['Todos'] => add to mutation and let it know that this mutation invalidates cache with tag

-- so data will automatically be re-fetched if tag is invaldidated

- transformResponse => mutates/transforms response the way you need the data. can sort, remove some parts etc.




SOME QUESTIONS THAT WERE ANSWERED SO FAR:

createApi   --- much like axios, separating api fetching logic separate from components and use custom hooks
fetchBaseQuery
tagTypes    --------  adds tags to cached data
invalidatesTags    ------ revalidates data when tags of cached data become invalidated (updated data)
transformResponse    ---  mutates/transforms response the way you need the data. can sort, remove some parts etc.
entity adapter --- entity state object, holds array of ids of each entity , much like state




// Export hooks for usage in functional components, which are
// auto-generated based on the defined endpoints
// start with use <endpoint method name> and Query or Mutation
export const {
  useGetTodosQuery,
  useAddTodoMutation,
  useUpdateTodoMutation,
  useDeleteTodoMutation,
} = apiSlice;


















